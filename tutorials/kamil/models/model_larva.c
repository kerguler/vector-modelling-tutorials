/* 
 *  This code was automatically generated by PopJSON (v.1.3.6) for Population (v.0.1.7)
 * 
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  See the GNU General Public License for more details:
 *  <https://www.gnu.org/licenses/>
 */

#include <math.h>
#include "population.h"

#define CHECK(x) (isnan(x) || isinf(x))

#define NumPar 12
#define NumPop 1
#define NumInt 4
#define NumEnv 1

#define n2m_L 0
#define n2m_l 1
#define n2m_R 2
#define n2m_r 3
#define n2m_M 4
#define n2m_X 5
#define d2m_L 6
#define d2m_l 7
#define d2m_R 8
#define d2m_r 9
#define d2m_M 10
#define d2m_X 11

#define Lmort 0
#define Ldev 1


double dmin(double a, double b) { return a < b ? a : b; }
double dmax(double a, double b) { return a > b ? a : b; }

int TIME;
int TIMEF;

double *model_param;
double *envir_temp;

double larva_to_pupa;
double larva_death;
double n2m;
double d2m;


#define dsig(T,L,l,R,r,M,X) (((M) + ((X) / ((1.0 + exp((exp((l)) * ((L) - (T))))) * (1.0 + exp((exp((r)) * ((T) - ((L) + (R))))))))))
double define_dsig(double T, double L, double l, double R, double r, double M, double X) {return ((M) + ((X) / ((1.0 + exp((exp((l)) * ((L) - (T))))) * (1.0 + exp((exp((r)) * ((T) - ((L) + (R)))))))));}

void prepare_tprobs(int numcol, double *ttprobs, double *tprobs) {
    int rA, rB, i = 0;
    double sum;
    for (i=0, rB=0; rB<numcol; rB++) {
        sum = 1.0;
        for (rA=0; rA<numcol; rA++, i++) {
            tprobs[i] = sum <= 0.0 ? 1.0 : ttprobs[i] / sum;
            sum -= ttprobs[i];
        }
    }
}

void init(int *no, int *np, int *ni, int *ne, int *st) {
    spop2_set_eps(0.000001);

    *no = NumPop;
    *np = NumPar;
    *ni = NumInt;
    *ne = NumEnv;
    *st = 0;
}

void parnames(char **names, double *param, double *parmin, double *parmax) {
    char temp[NumPop+NumPar+NumInt+NumEnv][256] = {
        "larva",
        "n2m_L", "n2m_l", "n2m_R", "n2m_r", "n2m_M", "n2m_X", "d2m_L", "d2m_l", "d2m_R", "d2m_r", "d2m_M", "d2m_X",
        "n2m", "d2m",
        "larva_to_pupa", "larva_death",
        "temp",
    };

    int i;
    for (i=0; i<(NumPop+NumPar+NumInt+NumEnv); i++)
        names[i] = strdup(temp[i]);

    param[n2m_L] = 15;
    parmin[n2m_L] = 15;
    parmax[n2m_L] = 15;
    param[n2m_l] = 1;
    parmin[n2m_l] = 1;
    parmax[n2m_l] = 1;
    param[n2m_R] = 20;
    parmin[n2m_R] = 20;
    parmax[n2m_R] = 20;
    param[n2m_r] = 1;
    parmin[n2m_r] = 1;
    parmax[n2m_r] = 1;
    param[n2m_M] = 24;
    parmin[n2m_M] = 24;
    parmax[n2m_M] = 24;
    param[n2m_X] = 2000;
    parmin[n2m_X] = 2000;
    parmax[n2m_X] = 2000;
    param[d2m_L] = 15;
    parmin[d2m_L] = 15;
    parmax[d2m_L] = 15;
    param[d2m_l] = 1;
    parmin[d2m_l] = 1;
    parmax[d2m_l] = 1;
    param[d2m_R] = 20;
    parmin[d2m_R] = 20;
    parmax[d2m_R] = 20;
    param[d2m_r] = 1;
    parmin[d2m_r] = 1;
    parmax[d2m_r] = 1;
    param[d2m_M] = 24;
    parmin[d2m_M] = 24;
    parmax[d2m_M] = 24;
    param[d2m_X] = 2000;
    parmin[d2m_X] = 2000;
    parmax[d2m_X] = 2000;
}

void destroy(void) {
}

void sim(int *tf, int *rep, double *envir, double *pr, double *y0, char **file_from, char **file_to, double *ret, double *iret, int *success) {

    char *file0 = *file_from;
    char *file1 = *file_to;

    TIME = 0;
    TIMEF = *tf;

    model_param = pr;

    envir_temp = envir + 1; envir += (int)round(*envir) + 1;


    population larva;

    number num = numZERO;
    char arbiters[3];
    number key[3];
    number size_larva;
    number completed_larva[3];
    larva_to_pupa = 0.0;
    larva_death = 0.0;
    double par[4];

    FILE *file;
    number *buff = 0;
    unsigned int buffsz = 0;
    if (file0 && file0[0]!=' ') {
        file = fopen(file0,"rb");
        if (!file) {
            *success = 0;
            goto endall;
        }
        rewind(file);
    }

    if (file0 && file0[0]!=' ') {
        fread(&buffsz, sizeof(unsigned int), 1, file);
        buff = (number *)malloc(buffsz);
        fread(buff, buffsz, 1, file);
        larva = spop2_loadstate(buff);


        free(buff);

    } else {
        arbiters[0] = ACC_ERLANG;
        key[0] = numZERO;
        arbiters[1] = ACC_ERLANG;
        key[1] = numZERO;
        arbiters[2] = STOP;
        key[2] = numZERO;
        larva = spop2_init(arbiters, DETERMINISTIC);
        if (y0[0]) { num.d = y0[0]; spop2_add(larva, key, num); }


    }

    if (file0 && file0[0]!=' ') {
        fclose(file);
    }

    n2m = 0.0;
    d2m = 0.0;

    size_larva = spop2_size(larva);

    ret[0] = size_larva.d;
    if (CHECK(ret[0])) {goto endall;};

    ret += 1;

    for (TIME=1; TIME<TIMEF; TIME++) {
        n2m = dsig(envir_temp[(int)(TIME-1)], model_param[n2m_L], model_param[n2m_l], model_param[n2m_R], model_param[n2m_r], model_param[n2m_M], model_param[n2m_X]);
        d2m = dsig(envir_temp[(int)(TIME-1)], model_param[d2m_L], model_param[d2m_l], model_param[d2m_R], model_param[d2m_r], model_param[d2m_M], model_param[d2m_X]);

        if (*rep >= 0) {
                par[0] = n2m;
                par[1] = n2m;
                par[2] = d2m;
                par[3] = (0.25 * d2m);
                spop2_step(larva, par, &size_larva, completed_larva, 0);

                larva_to_pupa = completed_larva[Ldev].d;

                larva_death = completed_larva[Lmort].d;









        }

        ret[0] = size_larva.d;
        if (CHECK(ret[0])) {goto endall;};

        ret += 1;

        iret[0] = n2m;
        if (CHECK(iret[0])) {goto endall;};
        iret[1] = d2m;
        if (CHECK(iret[1])) {goto endall;};

        iret[2] = larva_to_pupa;
        if (CHECK(iret[2])) {goto endall;};
        iret[3] = larva_death;
        if (CHECK(iret[3])) {goto endall;};


        iret += 4;

    }

  endall:

    *success = TIME;

    if (file1 && file1[0]!=' ') {
        file = fopen(file1,"wb");
        if (!file) {
            *success = 0;
        } else {
            rewind(file);

            buffsz = spop2_buffsize(larva);
            buff = spop2_savestate(larva);
            fwrite(&buffsz, sizeof(unsigned int), 1, file);
            fwrite(buff, buffsz, 1, file);
            free(buff);

            fclose(file);
        }
    }

    spop2_free(&larva);

}

int main(int argc, char *argv[]) {
    return 0;
}

