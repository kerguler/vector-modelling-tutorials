/* 
 *  This code was automatically generated by PopJSON (v.1.3.6) for Population (v.0.1.7)
 * 
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  See the GNU General Public License for more details:
 *  <https://www.gnu.org/licenses/>
 */

#include <math.h>
#include "population.h"

#define CHECK(x) (isnan(x) || isinf(x))

#define NumPar 59
#define NumPop 7
#define NumInt 34
#define NumEnv 7

#define par_E_death_L 0
#define par_E_death_l 1
#define par_E_death_R 2
#define par_E_death_r 3
#define par_E_death_X 4
#define par_E_death_str 5
#define par_E_death_dsc 6
#define par_E_dev_R 7
#define par_E_dev_r 8
#define par_E_dev_min 9
#define par_E_dev_max 10
#define par_E_to_L 11
#define par_Eh_dev 12
#define par_Eh_bs_thr 13
#define par_Eh_T_thr 14
#define par_L_to_P 15
#define par_L_death_L 16
#define par_L_death_l 17
#define par_L_death_R 18
#define par_L_death_r 19
#define par_L_death_X 20
#define par_L_death_str 21
#define par_L_dev_min 22
#define par_L_dev_max 23
#define par_L_dev_a 24
#define par_L_fdens 25
#define par_L_fdens_str 26
#define par_L_fdens_mort 27
#define par_L_fdens_dev 28
#define par_P_death_L 29
#define par_P_death_l 30
#define par_P_death_R 31
#define par_P_death_r 32
#define par_P_death_X 33
#define par_P_death_str 34
#define par_P_dev_min 35
#define par_P_dev_max 36
#define par_P_dev_a 37
#define par_P_to_A 38
#define par_A_death_str 39
#define par_female 40
#define par_bs_prec 41
#define par_bs_pdens 42
#define par_bs_nevap 43
#define par_Khum 44
#define par_kvec 45
#define par_F4_M 46
#define par_F4_a 47
#define par_F4_b 48
#define par_gc_X 49
#define par_gc_M 50
#define par_gc_a 51
#define par_A_life_L 52
#define par_A_life_l 53
#define par_A_life_R 54
#define par_A_life_r 55
#define par_A_life_H 56
#define par_factor_size 57
#define par_factor_size_off 58

#define proc_E_lifetime 0
#define proc_E_dev 1
#define proc_Eh_lifetime 0
#define proc_Eh_dev 1
#define proc_L_lifetime 0
#define proc_L_age 1
#define proc_L_dev 2
#define proc_P_lifetime 0
#define proc_P_dev 1
#define proc_P_size 2
#define proc_Afj_lifetime 0
#define proc_Afj_fbm 1
#define proc_Afj_size 2
#define proc_Af_lifetime 0
#define proc_Af_bm 1
#define proc_Af_size 2
#define proc_Afg_lifetime 0
#define proc_Afg_gc 1
#define proc_Afg_size 2

double par_maxdev = 8760;
double par_inf = 10000000000000;
double par_eps = 1e-13;

double dmin(double a, double b) { return a < b ? a : b; }
double dmax(double a, double b) { return a > b ? a : b; }

int TIME;
int TIMEF;

double *model_param;
double *envir_temp;
double *envir_prec;
double *envir_evap;
double *envir_rehum;
double *envir_pdens;
double *envir_experiment;
double *envir_configure;

double trans_E_to_Eh;
double trans_Eh_to_L;
double trans_Afg_gc;
double trans_Afg_to_E;
double trans_Af_to_E;
double trans_Af;
double trans_Af_X;
double trans_intro_Afj;
double trans_Eh_to_Eh;
double trans_L_to_P;
double trans_P_to_Afj;
double trans_Afj_to_Af;
double trans_Af_to_Afg;
double trans_Afg_to_Af;
double int_bsvol_add;
double int_bsvol_remain;
double bsvol;
double int_frac_dsc;
double int_E_lifetime;
double int_E_devtime;
double int_E_lifetime_dsc;
double int_L_fdens;
double int_L_fdens_mort_frac;
double int_L_fdens_dev_frac;
double int_L_lifetime;
double int_L_devtime;
double int_P_lifetime;
double int_P_devtime;
double int_Af_lifetime;
double int_Af_gctime;
double int_fecundity;
double int_lam_hum;
double int_lam_novec;
double trans_Af_bm;


#define briere1(T,L,R,a) ((((((T) > (L)) && ((T) <= ((L) + (R))))) ? ((exp((a)) * (273.15 + (T)) * ((T) - (L)) * sqrt((((L) + (R)) - (T))))) : (0.0)))
#define sig(T,L,H,M,S) (((L) + (((H) - (L)) / (1.0 + exp(((S) * ((T) - (M))))))))
#define dsig(T,L,R,H) (((H) / ((1.0 + exp(((L) - (T)))) * (1.0 + exp(((T) - ((L) + (R))))))))
#define dsigi(T,L,R,H) (((H) - dsig((T), (L), (R), (H))))
#define dsigs(T,R,r,M,H) (((M) + ((H) / ((1.0 + exp((exp((r)) * ((T) - (R)))))))))
#define dsigx(T,L,l,R,r,H) (((H) / ((1.0 + exp((exp((l)) * ((L) - (T))))) * (1.0 + exp((exp((r)) * ((T) - ((L) + (R)))))))))
#define dsqrt(T,L,R,H) (dmax((L), ((((T) > (R))) ? (((H) * pow(((T) - (R)), 0.1))) : ((L)))))
#define fexp(T,X,M,a) (dmax((M), ((X) * exp((-1.0 * (a) * (T))))))
#define fpoly(T,M,a,b) (((b) + ((a) * pow(((T) - (M)), 2.0))))
#define fun_factor_size(p,l,a,b) (((l) * (1.0 + dmax(0.0, ((b) + ((a) * (p)))))))
#define fun_nevap(e,C) ((1.0 - (dmin(0.0, (e)) / (dmin(0.0, (e)) - (C)))))
double define_briere1(double T, double L, double R, double a) {return (((((T) > (L)) && ((T) <= ((L) + (R))))) ? ((exp((a)) * (273.15 + (T)) * ((T) - (L)) * sqrt((((L) + (R)) - (T))))) : (0.0));}
double define_sig(double T, double L, double H, double M, double S) {return ((L) + (((H) - (L)) / (1.0 + exp(((S) * ((T) - (M)))))));}
double define_dsig(double T, double L, double R, double H) {return ((H) / ((1.0 + exp(((L) - (T)))) * (1.0 + exp(((T) - ((L) + (R)))))));}
double define_dsigi(double T, double L, double R, double H) {return ((H) - dsig((T), (L), (R), (H)));}
double define_dsigs(double T, double R, double r, double M, double H) {return ((M) + ((H) / ((1.0 + exp((exp((r)) * ((T) - (R))))))));}
double define_dsigx(double T, double L, double l, double R, double r, double H) {return ((H) / ((1.0 + exp((exp((l)) * ((L) - (T))))) * (1.0 + exp((exp((r)) * ((T) - ((L) + (R))))))));}
double define_dsqrt(double T, double L, double R, double H) {return dmax((L), ((((T) > (R))) ? (((H) * pow(((T) - (R)), 0.1))) : ((L))));}
double define_fexp(double T, double X, double M, double a) {return dmax((M), ((X) * exp((-1.0 * (a) * (T)))));}
double define_fpoly(double T, double M, double a, double b) {return ((b) + ((a) * pow(((T) - (M)), 2.0)));}
double define_fun_factor_size(double p, double l, double a, double b) {return ((l) * (1.0 + dmax(0.0, ((b) + ((a) * (p))))));}
double define_fun_nevap(double e, double C) {return (1.0 - (dmin(0.0, (e)) / (dmin(0.0, (e)) - (C))));}

void fun_harvest_trans_Eh_to_Eh(number *key, number num, number *newkey, double *frac) {
    newkey[0].d=key[proc_Eh_lifetime].d;
    newkey[1].d=0;
    *frac = 1;
}

void fun_harvest_trans_L_to_P(number *key, number num, number *newkey, double *frac) {
    newkey[0].d=0.0;
    newkey[1].d=0.0;
    newkey[2].d=key[proc_L_age].i;
    *frac = model_param[par_L_to_P];
}

void fun_harvest_trans_P_to_Afj(number *key, number num, number *newkey, double *frac) {
    newkey[0].d=0.0;
    newkey[1].d=0.0;
    newkey[2].d=key[proc_P_size].d;
    *frac = (model_param[par_P_to_A] * model_param[par_female]);
}

void fun_harvest_trans_Afj_to_Af(number *key, number num, number *newkey, double *frac) {
    newkey[0].d=key[proc_Afj_lifetime].d;
    newkey[1].i=0.0;
    newkey[2].d=key[proc_Afj_size].d;
    *frac = 1.0;
}

void fun_harvest_trans_Af_to_Afg(number *key, number num, number *newkey, double *frac) {
    newkey[0].d=key[proc_Af_lifetime].d;
    newkey[1].d=0.0;
    newkey[2].d=key[proc_Af_size].d;
    *frac = 1.0;
}

void fun_harvest_trans_Afg_to_Af(number *key, number num, number *newkey, double *frac) {
    newkey[0].d=key[proc_Afg_lifetime].d;
    newkey[1].i=0.0;
    newkey[2].d=key[proc_Afg_size].d;
    *frac = 1.0;
}

void fun_hazpar_proc_Afj_lifetime_pop_Afj(const number *key, const number num, double *par) {
    par[0] = fun_factor_size(key[proc_Afj_size].d, int_Af_lifetime, model_param[par_factor_size], model_param[par_factor_size_off]);
    par[1] = (model_param[par_A_death_str] * fun_factor_size(key[proc_Afj_size].d, int_Af_lifetime, model_param[par_factor_size], model_param[par_factor_size_off]));
}

void fun_hazpar_proc_Af_lifetime_pop_Af(const number *key, const number num, double *par) {
    par[0] = fun_factor_size(key[proc_Af_size].d, int_Af_lifetime, model_param[par_factor_size], model_param[par_factor_size_off]);
    par[1] = (model_param[par_A_death_str] * fun_factor_size(key[proc_Af_size].d, int_Af_lifetime, model_param[par_factor_size], model_param[par_factor_size_off]));
}

void fun_hazpar_proc_Afg_lifetime_pop_Afg(const number *key, const number num, double *par) {
    par[0] = fun_factor_size(key[proc_Afg_size].d, int_Af_lifetime, model_param[par_factor_size], model_param[par_factor_size_off]);
    par[1] = (model_param[par_A_death_str] * fun_factor_size(key[proc_Afg_size].d, int_Af_lifetime, model_param[par_factor_size], model_param[par_factor_size_off]));
}

void prepare_tprobs(int numcol, double *ttprobs, double *tprobs) {
    int rA, rB, i = 0;
    double sum;
    for (i=0, rB=0; rB<numcol; rB++) {
        sum = 1.0;
        for (rA=0; rA<numcol; rA++, i++) {
            tprobs[i] = sum <= 0.0 ? 1.0 : ttprobs[i] / sum;
            sum -= ttprobs[i];
        }
    }
}

void init(int *no, int *np, int *ni, int *ne, int *st) {
    spop2_set_eps(1e-9);

    *no = NumPop;
    *np = NumPar;
    *ni = NumInt;
    *ne = NumEnv;
    *st = 0;
}

void parnames(char **names, double *param, double *parmin, double *parmax) {
    char temp[NumPop+NumPar+NumInt+NumEnv][256] = {
        "pop_E", "pop_Eh", "pop_L", "pop_P", "pop_Afj", "pop_Af", "pop_Afg",
        "par_E_death_L", "par_E_death_l", "par_E_death_R", "par_E_death_r", "par_E_death_X", "par_E_death_str", "par_E_death_dsc", "par_E_dev_R", "par_E_dev_r", "par_E_dev_min", "par_E_dev_max", "par_E_to_L", "par_Eh_dev", "par_Eh_bs_thr", "par_Eh_T_thr", "par_L_to_P", "par_L_death_L", "par_L_death_l", "par_L_death_R", "par_L_death_r", "par_L_death_X", "par_L_death_str", "par_L_dev_min", "par_L_dev_max", "par_L_dev_a", "par_L_fdens", "par_L_fdens_str", "par_L_fdens_mort", "par_L_fdens_dev", "par_P_death_L", "par_P_death_l", "par_P_death_R", "par_P_death_r", "par_P_death_X", "par_P_death_str", "par_P_dev_min", "par_P_dev_max", "par_P_dev_a", "par_P_to_A", "par_A_death_str", "par_female", "par_bs_prec", "par_bs_pdens", "par_bs_nevap", "par_Khum", "par_kvec", "par_F4_M", "par_F4_a", "par_F4_b", "par_gc_X", "par_gc_M", "par_gc_a", "par_A_life_L", "par_A_life_l", "par_A_life_R", "par_A_life_r", "par_A_life_H", "par_factor_size", "par_factor_size_off",
        "int_bsvol_add", "int_bsvol_remain", "bsvol", "int_frac_dsc", "int_E_lifetime", "int_E_devtime", "int_E_lifetime_dsc", "int_L_fdens", "int_L_fdens_mort_frac", "int_L_fdens_dev_frac", "int_L_lifetime", "int_L_devtime", "int_P_lifetime", "int_P_devtime", "int_Af_lifetime", "int_Af_gctime", "int_fecundity", "int_lam_hum", "int_lam_novec", "trans_Af_bm",
        "trans_E_to_Eh", "trans_Eh_to_L", "trans_Afg_gc", "trans_Afg_to_E", "trans_Af_to_E", "trans_Af", "trans_Af_X", "trans_intro_Afj",
        "trans_Eh_to_Eh", "trans_L_to_P", "trans_P_to_Afj", "trans_Afj_to_Af", "trans_Af_to_Afg", "trans_Afg_to_Af",
        "temp", "prec", "evap", "rehum", "pdens", "experiment", "configure",
    };

    int i;
    for (i=0; i<(NumPop+NumPar+NumInt+NumEnv); i++)
        names[i] = strdup(temp[i]);

    param[par_E_death_L] = 10;
    parmin[par_E_death_L] = -20;
    parmax[par_E_death_L] = 100;
    param[par_E_death_l] = -0.88795004;
    parmin[par_E_death_l] = -6;
    parmax[par_E_death_l] = 6;
    param[par_E_death_R] = 25;
    parmin[par_E_death_R] = -10;
    parmax[par_E_death_R] = 50;
    param[par_E_death_r] = -0.14661669;
    parmin[par_E_death_r] = -6;
    parmax[par_E_death_r] = 6;
    param[par_E_death_X] = 400;
    parmin[par_E_death_X] = 0;
    parmax[par_E_death_X] = 8760;
    param[par_E_death_str] = 1;
    parmin[par_E_death_str] = 0.1;
    parmax[par_E_death_str] = 1;
    param[par_E_death_dsc] = 10;
    parmin[par_E_death_dsc] = 1;
    parmax[par_E_death_dsc] = 1000;
    param[par_E_dev_R] = -6.00179088;
    parmin[par_E_dev_R] = -20;
    parmax[par_E_dev_R] = 100;
    param[par_E_dev_r] = -1.82367405;
    parmin[par_E_dev_r] = -6;
    parmax[par_E_dev_r] = 6;
    param[par_E_dev_min] = 16.53137616;
    parmin[par_E_dev_min] = 1;
    parmax[par_E_dev_min] = 10000;
    param[par_E_dev_max] = 12877.17396456;
    parmin[par_E_dev_max] = 1;
    parmax[par_E_dev_max] = 100000;
    param[par_E_to_L] = 1;
    parmin[par_E_to_L] = 0;
    parmax[par_E_to_L] = 1;
    param[par_Eh_dev] = 240;
    parmin[par_Eh_dev] = 0;
    parmax[par_Eh_dev] = 10000;
    param[par_Eh_bs_thr] = 0.5;
    parmin[par_Eh_bs_thr] = 0;
    parmax[par_Eh_bs_thr] = 1000;
    param[par_Eh_T_thr] = 15;
    parmin[par_Eh_T_thr] = -10;
    parmax[par_Eh_T_thr] = 50;
    param[par_L_to_P] = 0.9;
    parmin[par_L_to_P] = 0;
    parmax[par_L_to_P] = 1;
    param[par_L_death_L] = 12;
    parmin[par_L_death_L] = -10;
    parmax[par_L_death_L] = 100;
    param[par_L_death_l] = 0.6;
    parmin[par_L_death_l] = -6;
    parmax[par_L_death_l] = 6;
    param[par_L_death_R] = 22;
    parmin[par_L_death_R] = -10;
    parmax[par_L_death_R] = 50;
    param[par_L_death_r] = 0.92954879;
    parmin[par_L_death_r] = -6;
    parmax[par_L_death_r] = 6;
    param[par_L_death_X] = 1000;
    parmin[par_L_death_X] = 0;
    parmax[par_L_death_X] = 8760;
    param[par_L_death_str] = 0.5;
    parmin[par_L_death_str] = 0.1;
    parmax[par_L_death_str] = 1;
    param[par_L_dev_min] = 0;
    parmin[par_L_dev_min] = 0;
    parmax[par_L_dev_min] = 1000;
    param[par_L_dev_max] = 2051.557170044333;
    parmin[par_L_dev_max] = 1;
    parmax[par_L_dev_max] = 8760;
    param[par_L_dev_a] = 0.1;
    parmin[par_L_dev_a] = 0;
    parmax[par_L_dev_a] = 1;
    param[par_L_fdens] = 300;
    parmin[par_L_fdens] = 0;
    parmax[par_L_fdens] = 10000;
    param[par_L_fdens_str] = -4.8;
    parmin[par_L_fdens_str] = -6;
    parmax[par_L_fdens_str] = 6;
    param[par_L_fdens_mort] = 1;
    parmin[par_L_fdens_mort] = 0;
    parmax[par_L_fdens_mort] = 1;
    param[par_L_fdens_dev] = 0.1;
    parmin[par_L_fdens_dev] = 0;
    parmax[par_L_fdens_dev] = 1;
    param[par_P_death_L] = 17;
    parmin[par_P_death_L] = -10;
    parmax[par_P_death_L] = 100;
    param[par_P_death_l] = 0.6;
    parmin[par_P_death_l] = -2;
    parmax[par_P_death_l] = 2;
    param[par_P_death_R] = 17;
    parmin[par_P_death_R] = -10;
    parmax[par_P_death_R] = 50;
    param[par_P_death_r] = 0.92954879;
    parmin[par_P_death_r] = -2;
    parmax[par_P_death_r] = 2;
    param[par_P_death_X] = 1000;
    parmin[par_P_death_X] = 0;
    parmax[par_P_death_X] = 8760;
    param[par_P_death_str] = 0.5;
    parmin[par_P_death_str] = 0.1;
    parmax[par_P_death_str] = 1;
    param[par_P_dev_min] = 36;
    parmin[par_P_dev_min] = 0;
    parmax[par_P_dev_min] = 1000;
    param[par_P_dev_max] = 2051.557170044333;
    parmin[par_P_dev_max] = 1;
    parmax[par_P_dev_max] = 8760;
    param[par_P_dev_a] = 0.15;
    parmin[par_P_dev_a] = 0;
    parmax[par_P_dev_a] = 1;
    param[par_P_to_A] = 0.9;
    parmin[par_P_to_A] = 0;
    parmax[par_P_to_A] = 1;
    param[par_A_death_str] = 0.5;
    parmin[par_A_death_str] = 0.1;
    parmax[par_A_death_str] = 1;
    param[par_female] = 0.5;
    parmin[par_female] = 0;
    parmax[par_female] = 1;
    param[par_bs_prec] = 0.0001;
    parmin[par_bs_prec] = 0;
    parmax[par_bs_prec] = 1;
    param[par_bs_pdens] = 0.000001;
    parmin[par_bs_pdens] = 0;
    parmax[par_bs_pdens] = 1;
    param[par_bs_nevap] = 20;
    parmin[par_bs_nevap] = 1e-13;
    parmax[par_bs_nevap] = 1000;
    param[par_Khum] = 100;
    parmin[par_Khum] = 0;
    parmax[par_Khum] = 1000;
    param[par_kvec] = 100;
    parmin[par_kvec] = 0;
    parmax[par_kvec] = 1000;
    param[par_F4_M] = 26;
    parmin[par_F4_M] = 0;
    parmax[par_F4_M] = 1000;
    param[par_F4_a] = -0.5;
    parmin[par_F4_a] = -100;
    parmax[par_F4_a] = 100;
    param[par_F4_b] = 45;
    parmin[par_F4_b] = 0;
    parmax[par_F4_b] = 100;
    param[par_gc_X] = 1700;
    parmin[par_gc_X] = 0;
    parmax[par_gc_X] = 10000;
    param[par_gc_M] = 1;
    parmin[par_gc_M] = -100;
    parmax[par_gc_M] = 100;
    param[par_gc_a] = 0.1;
    parmin[par_gc_a] = 0;
    parmax[par_gc_a] = 100;
    param[par_A_life_L] = 16.5;
    parmin[par_A_life_L] = 0;
    parmax[par_A_life_L] = 1000;
    param[par_A_life_l] = 1;
    parmin[par_A_life_l] = -6;
    parmax[par_A_life_l] = 6;
    param[par_A_life_R] = 15;
    parmin[par_A_life_R] = 0;
    parmax[par_A_life_R] = 1000;
    param[par_A_life_r] = -1.2;
    parmin[par_A_life_r] = -6;
    parmax[par_A_life_r] = 6;
    param[par_A_life_H] = 870;
    parmin[par_A_life_H] = 0;
    parmax[par_A_life_H] = 10000;
    param[par_factor_size] = 0.001;
    parmin[par_factor_size] = 0;
    parmax[par_factor_size] = 10;
    param[par_factor_size_off] = 0.1;
    parmin[par_factor_size_off] = 0;
    parmax[par_factor_size_off] = 10;
}

void destroy(void) {
}

void sim(int *tf, int *rep, double *envir, double *pr, double *y0, char **file_from, char **file_to, double *ret, double *iret, int *success) {

    char *file0 = *file_from;
    char *file1 = *file_to;

    TIME = 0;
    TIMEF = *tf;

    model_param = pr;

    envir_temp = envir + 1; envir += (int)round(*envir) + 1;
    envir_prec = envir + 1; envir += (int)round(*envir) + 1;
    envir_evap = envir + 1; envir += (int)round(*envir) + 1;
    envir_rehum = envir + 1; envir += (int)round(*envir) + 1;
    envir_pdens = envir + 1; envir += (int)round(*envir) + 1;
    envir_experiment = envir + 1; envir += (int)round(*envir) + 1;
    envir_configure = envir + 1; envir += (int)round(*envir) + 1;


    population pop_E;
    population pop_Eh;
    population pop_L;
    population pop_P;
    population pop_Afj;
    population pop_Af;
    population pop_Afg;

    number num = numZERO;
    char arbiters[4];
    number key[4];
    number size_pop_E;
    number size_pop_Eh;
    number size_pop_L;
    number size_pop_P;
    number size_pop_Afj;
    number size_pop_Af;
    number size_pop_Afg;
    number completed_pop_E[4];
    number completed_pop_Eh[4];
    number completed_pop_L[4];
    number completed_pop_P[4];
    number completed_pop_Afj[4];
    number completed_pop_Af[4];
    number completed_pop_Afg[4];
    population popdone_pop_Eh[4];
    population popdone_pop_L[4];
    population popdone_pop_P[4];
    population popdone_pop_Afj[4];
    population popdone_pop_Af[4];
    population popdone_pop_Afg[4];
    trans_E_to_Eh = 0.0;
    trans_Eh_to_L = 0.0;
    trans_Afg_gc = 0.0;
    trans_Afg_to_E = 0.0;
    trans_Af_to_E = 0.0;
    trans_Af = 0.0;
    trans_Af_X = 0.0;
    trans_intro_Afj = 0.0;
    trans_Eh_to_Eh = 0.0;
    trans_L_to_P = 0.0;
    trans_P_to_Afj = 0.0;
    trans_Afj_to_Af = 0.0;
    trans_Af_to_Afg = 0.0;
    trans_Afg_to_Af = 0.0;
    double par[4];

    FILE *file;
    number *buff = 0;
    unsigned int buffsz = 0;
    if (file0 && file0[0]!=' ') {
        file = fopen(file0,"rb");
        if (!file) {
            *success = 0;
            goto endall;
        }
        rewind(file);
    }

    if (file0 && file0[0]!=' ') {
        fread(&buffsz, sizeof(unsigned int), 1, file);
        buff = (number *)malloc(buffsz);
        fread(buff, buffsz, 1, file);
        pop_E = spop2_loadstate(buff);


        free(buff);

        fread(&buffsz, sizeof(unsigned int), 1, file);
        buff = (number *)malloc(buffsz);
        fread(buff, buffsz, 1, file);
        pop_Eh = spop2_loadstate(buff);

        popdone_pop_Eh[0] = spop2_loadstate_empty(buff);
        popdone_pop_Eh[1] = spop2_loadstate_empty(buff);
        popdone_pop_Eh[2] = spop2_loadstate_empty(buff);
        popdone_pop_Eh[3] = spop2_loadstate_empty(buff);

        free(buff);

        fread(&buffsz, sizeof(unsigned int), 1, file);
        buff = (number *)malloc(buffsz);
        fread(buff, buffsz, 1, file);
        pop_L = spop2_loadstate(buff);

        popdone_pop_L[0] = spop2_loadstate_empty(buff);
        popdone_pop_L[1] = spop2_loadstate_empty(buff);
        popdone_pop_L[2] = spop2_loadstate_empty(buff);
        popdone_pop_L[3] = spop2_loadstate_empty(buff);

        free(buff);

        fread(&buffsz, sizeof(unsigned int), 1, file);
        buff = (number *)malloc(buffsz);
        fread(buff, buffsz, 1, file);
        pop_P = spop2_loadstate(buff);

        popdone_pop_P[0] = spop2_loadstate_empty(buff);
        popdone_pop_P[1] = spop2_loadstate_empty(buff);
        popdone_pop_P[2] = spop2_loadstate_empty(buff);
        popdone_pop_P[3] = spop2_loadstate_empty(buff);

        free(buff);

        fread(&buffsz, sizeof(unsigned int), 1, file);
        buff = (number *)malloc(buffsz);
        fread(buff, buffsz, 1, file);
        pop_Afj = spop2_loadstate(buff);

        popdone_pop_Afj[0] = spop2_loadstate_empty(buff);
        popdone_pop_Afj[1] = spop2_loadstate_empty(buff);
        popdone_pop_Afj[2] = spop2_loadstate_empty(buff);
        popdone_pop_Afj[3] = spop2_loadstate_empty(buff);

        free(buff);

        fread(&buffsz, sizeof(unsigned int), 1, file);
        buff = (number *)malloc(buffsz);
        fread(buff, buffsz, 1, file);
        pop_Af = spop2_loadstate(buff);

        popdone_pop_Af[0] = spop2_loadstate_empty(buff);
        popdone_pop_Af[1] = spop2_loadstate_empty(buff);
        popdone_pop_Af[2] = spop2_loadstate_empty(buff);
        popdone_pop_Af[3] = spop2_loadstate_empty(buff);

        free(buff);

        fread(&buffsz, sizeof(unsigned int), 1, file);
        buff = (number *)malloc(buffsz);
        fread(buff, buffsz, 1, file);
        pop_Afg = spop2_loadstate(buff);

        popdone_pop_Afg[0] = spop2_loadstate_empty(buff);
        popdone_pop_Afg[1] = spop2_loadstate_empty(buff);
        popdone_pop_Afg[2] = spop2_loadstate_empty(buff);
        popdone_pop_Afg[3] = spop2_loadstate_empty(buff);

        free(buff);

    } else {
        arbiters[0] = ACC_ERLANG;
        key[0] = numZERO;
        arbiters[1] = ACC_FIXED;
        key[1] = numZERO;
        arbiters[2] = STOP;
        key[2] = numZERO;
        arbiters[3] = STOP;
        key[3] = numZERO;
        pop_E = spop2_init(arbiters, DETERMINISTIC);
        if (y0[0]) { num.d = y0[0]; spop2_add(pop_E, key, num); }


        arbiters[0] = ACC_ERLANG;
        key[0] = numZERO;
        arbiters[1] = ACC_FIXED;
        key[1] = numZERO;
        arbiters[2] = STOP;
        key[2] = numZERO;
        arbiters[3] = STOP;
        key[3] = numZERO;
        pop_Eh = spop2_init(arbiters, DETERMINISTIC);
        if (y0[1]) { num.d = y0[1]; spop2_add(pop_Eh, key, num); }

        popdone_pop_Eh[0] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Eh[1] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Eh[2] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Eh[3] = spop2_init(arbiters, DETERMINISTIC);

        arbiters[0] = ACC_ERLANG;
        key[0] = numZERO;
        arbiters[1] = AGE_FIXED;
        key[1] = numZERO;
        arbiters[2] = ACC_FIXED;
        key[2] = numZERO;
        arbiters[3] = STOP;
        key[3] = numZERO;
        pop_L = spop2_init(arbiters, DETERMINISTIC);
        if (y0[2]) { num.d = y0[2]; spop2_add(pop_L, key, num); }

        popdone_pop_L[0] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_L[1] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_L[2] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_L[3] = spop2_init(arbiters, DETERMINISTIC);

        arbiters[0] = ACC_ERLANG;
        key[0] = numZERO;
        arbiters[1] = ACC_FIXED;
        key[1] = numZERO;
        arbiters[2] = ACC_MEMORY;
        key[2] = numZERO;
        arbiters[3] = STOP;
        key[3] = numZERO;
        pop_P = spop2_init(arbiters, DETERMINISTIC);
        if (y0[3]) { num.d = y0[3]; spop2_add(pop_P, key, num); }

        popdone_pop_P[0] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_P[1] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_P[2] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_P[3] = spop2_init(arbiters, DETERMINISTIC);

        arbiters[0] = ACC_ERLANG;
        key[0] = numZERO;
        arbiters[1] = ACC_FIXED;
        key[1] = numZERO;
        arbiters[2] = ACC_MEMORY;
        key[2] = numZERO;
        arbiters[3] = STOP;
        key[3] = numZERO;
        pop_Afj = spop2_init(arbiters, DETERMINISTIC);
        pop_Afj->arbiters[0]->fun_q_par = fun_hazpar_proc_Afj_lifetime_pop_Afj;
        if (y0[4]) { num.d = y0[4]; spop2_add(pop_Afj, key, num); }

        popdone_pop_Afj[0] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Afj[1] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Afj[2] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Afj[3] = spop2_init(arbiters, DETERMINISTIC);

        arbiters[0] = ACC_ERLANG;
        key[0] = numZERO;
        arbiters[1] = NOAGE_CONST;
        key[1] = numZERO;
        arbiters[2] = ACC_MEMORY;
        key[2] = numZERO;
        arbiters[3] = STOP;
        key[3] = numZERO;
        pop_Af = spop2_init(arbiters, DETERMINISTIC);
        pop_Af->arbiters[0]->fun_q_par = fun_hazpar_proc_Af_lifetime_pop_Af;
        if (y0[5]) { num.d = y0[5]; spop2_add(pop_Af, key, num); }

        popdone_pop_Af[0] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Af[1] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Af[2] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Af[3] = spop2_init(arbiters, DETERMINISTIC);

        arbiters[0] = ACC_ERLANG;
        key[0] = numZERO;
        arbiters[1] = ACC_FIXED;
        key[1] = numZERO;
        arbiters[2] = ACC_MEMORY;
        key[2] = numZERO;
        arbiters[3] = STOP;
        key[3] = numZERO;
        pop_Afg = spop2_init(arbiters, DETERMINISTIC);
        pop_Afg->arbiters[0]->fun_q_par = fun_hazpar_proc_Afg_lifetime_pop_Afg;
        if (y0[6]) { num.d = y0[6]; spop2_add(pop_Afg, key, num); }

        popdone_pop_Afg[0] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Afg[1] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Afg[2] = spop2_init(arbiters, DETERMINISTIC);
        popdone_pop_Afg[3] = spop2_init(arbiters, DETERMINISTIC);

    }

    if (file0 && file0[0]!=' ') {
        fclose(file);
    }

    int_bsvol_add = 0.0;
    int_bsvol_remain = 0.0;
    bsvol = 0.0;
    int_frac_dsc = 0.0;
    int_E_lifetime = 0.0;
    int_E_devtime = 0.0;
    int_E_lifetime_dsc = 0.0;
    int_L_fdens = 0.0;
    int_L_fdens_mort_frac = 0.0;
    int_L_fdens_dev_frac = 0.0;
    int_L_lifetime = 0.0;
    int_L_devtime = 0.0;
    int_P_lifetime = 0.0;
    int_P_devtime = 0.0;
    int_Af_lifetime = 0.0;
    int_Af_gctime = 0.0;
    int_fecundity = 0.0;
    int_lam_hum = 0.0;
    int_lam_novec = 0.0;
    trans_Af_bm = 0.0;

    size_pop_E = spop2_size(pop_E);
    size_pop_Eh = spop2_size(pop_Eh);
    size_pop_L = spop2_size(pop_L);
    size_pop_P = spop2_size(pop_P);
    size_pop_Afj = spop2_size(pop_Afj);
    size_pop_Af = spop2_size(pop_Af);
    size_pop_Afg = spop2_size(pop_Afg);

    ret[0] = size_pop_E.d;
    if (CHECK(ret[0])) {goto endall;};
    ret[1] = size_pop_Eh.d;
    if (CHECK(ret[1])) {goto endall;};
    ret[2] = size_pop_L.d;
    if (CHECK(ret[2])) {goto endall;};
    ret[3] = size_pop_P.d;
    if (CHECK(ret[3])) {goto endall;};
    ret[4] = size_pop_Afj.d;
    if (CHECK(ret[4])) {goto endall;};
    ret[5] = size_pop_Af.d;
    if (CHECK(ret[5])) {goto endall;};
    ret[6] = size_pop_Afg.d;
    if (CHECK(ret[6])) {goto endall;};

    ret += 7;

    for (TIME=1; TIME<TIMEF; TIME++) {
        int_bsvol_add = ((model_param[par_bs_prec] * envir_prec[(int)(TIME-1)]) + (model_param[par_bs_pdens] * envir_pdens[(int)(TIME-1)]));
        int_bsvol_remain = (fun_nevap(envir_evap[(int)(TIME-1)], model_param[par_bs_nevap]) * bsvol);
        bsvol = (int_bsvol_add + int_bsvol_remain);
        int_frac_dsc = (model_param[par_E_death_dsc] * (envir_rehum[(int)(TIME-1)] / 100.0));
        int_E_lifetime = dsigx(envir_temp[(int)(TIME-1)], model_param[par_E_death_L], model_param[par_E_death_l], model_param[par_E_death_R], model_param[par_E_death_r], model_param[par_E_death_X]);
        int_E_devtime = dsigs(envir_temp[(int)(TIME-1)], model_param[par_E_dev_R], model_param[par_E_dev_r], model_param[par_E_dev_min], model_param[par_E_dev_max]);
        int_E_lifetime_dsc = (int_frac_dsc * int_E_lifetime);
        int_L_fdens = (((bsvol > par_eps)) ? (sig((size_pop_L.d / bsvol), 0.0, 1.0, model_param[par_L_fdens], exp(model_param[par_L_fdens_str]))) : (0.0));
        int_L_fdens_mort_frac = (model_param[par_L_fdens_mort] * int_L_fdens);
        int_L_fdens_dev_frac = (1.0 + (model_param[par_L_fdens_dev] * (1.0 - int_L_fdens)));
        int_L_lifetime = (int_L_fdens_mort_frac * dsigx(envir_temp[(int)(TIME-1)], model_param[par_L_death_L], model_param[par_L_death_l], model_param[par_L_death_R], model_param[par_L_death_r], model_param[par_L_death_X]));
        int_L_devtime = (int_L_fdens_dev_frac * fexp(envir_temp[(int)(TIME-1)], model_param[par_L_dev_max], model_param[par_L_dev_min], model_param[par_L_dev_a]));
        int_P_lifetime = (((bsvol <= par_eps)) ? (0.0) : (dsigx(envir_temp[(int)(TIME-1)], model_param[par_P_death_L], model_param[par_P_death_l], model_param[par_P_death_R], model_param[par_P_death_r], model_param[par_P_death_X])));
        int_P_devtime = (((bsvol <= par_eps)) ? (par_inf) : (fexp(envir_temp[(int)(TIME-1)], model_param[par_P_dev_max], model_param[par_P_dev_min], model_param[par_P_dev_a])));
        int_Af_lifetime = dsigx(envir_temp[(int)(TIME-1)], model_param[par_A_life_L], model_param[par_A_life_l], model_param[par_A_life_R], model_param[par_A_life_r], model_param[par_A_life_H]);
        int_Af_gctime = dmax(1.0, fexp(envir_temp[(int)(TIME-1)], model_param[par_gc_X], model_param[par_gc_M], model_param[par_gc_a]));
        int_fecundity = dmax(0.0, fpoly(envir_temp[(int)(TIME-1)], model_param[par_F4_M], model_param[par_F4_a], model_param[par_F4_b]));
        int_lam_hum = (model_param[par_Khum] * envir_pdens[(int)(TIME-1)]);
        int_lam_novec = (model_param[par_kvec] * int_fecundity);
        trans_Af_bm = (((int_lam_novec && int_lam_hum)) ? (exp((-1.0 * (((int_lam_novec * size_pop_Af.d) + int_lam_hum) / (int_lam_novec * int_lam_hum))))) : (0.0));

        if (*rep >= 0) {
                par[0] = int_E_lifetime;
                par[1] = (model_param[par_E_death_str] * int_E_lifetime);
                par[2] = int_E_devtime;
                par[3] = 0.0;
                spop2_step(pop_E, par, &size_pop_E, completed_pop_E, 0);

                par[0] = int_E_lifetime_dsc;
                par[1] = (model_param[par_E_death_str] * int_E_lifetime_dsc);
                par[2] = model_param[par_Eh_dev];
                par[3] = 0.0;
                spop2_step(pop_Eh, par, &size_pop_Eh, completed_pop_Eh, popdone_pop_Eh);

                par[0] = int_L_lifetime;
                par[1] = (model_param[par_L_death_str] * int_L_lifetime);
                par[2] = par_inf;
                par[3] = int_L_devtime;
                spop2_step(pop_L, par, &size_pop_L, completed_pop_L, popdone_pop_L);

                par[0] = int_P_lifetime;
                par[1] = (model_param[par_P_death_str] * int_P_lifetime);
                par[2] = int_P_devtime;
                par[3] = 0.0;
                spop2_step(pop_P, par, &size_pop_P, completed_pop_P, popdone_pop_P);

                par[0] = 0.0;
                par[1] = 0.0;
                par[2] = int_Af_gctime;
                par[3] = 0.0;
                spop2_step(pop_Afj, par, &size_pop_Afj, completed_pop_Afj, popdone_pop_Afj);

                par[0] = 0.0;
                par[1] = 0.0;
                par[2] = (((envir_configure[(int)0] == 0)) ? (trans_Af_bm) : (0.0));
                par[3] = 0.0;
                spop2_step(pop_Af, par, &size_pop_Af, completed_pop_Af, popdone_pop_Af);

                par[0] = 0.0;
                par[1] = 0.0;
                par[2] = int_Af_gctime;
                par[3] = 0.0;
                spop2_step(pop_Afg, par, &size_pop_Afg, completed_pop_Afg, popdone_pop_Afg);

                trans_E_to_Eh = completed_pop_E[proc_E_dev].d;

                key[0] = numZERO;
                key[1] = numZERO;
                key[2] = numZERO;
                key[3] = numZERO;
                num.d = trans_E_to_Eh;
                spop2_add(pop_Eh, key, num);

                size_pop_Eh.d += trans_E_to_Eh;
                trans_Eh_to_L = (model_param[par_E_to_L] * completed_pop_Eh[proc_Eh_dev].d);

                key[0] = numZERO;
                key[1] = numZERO;
                key[2] = numZERO;
                key[3] = numZERO;
                num.d = trans_Eh_to_L;
                spop2_add(pop_L, key, num);

                size_pop_L.d += trans_Eh_to_L;
                trans_Afg_gc = completed_pop_Afg[proc_Afg_gc].d;

                if ((envir_configure[(int)0] == 0)) {
                trans_Afg_to_E = (int_fecundity * completed_pop_Afg[proc_Afg_gc].d);

                key[0] = numZERO;
                key[1] = numZERO;
                key[2] = numZERO;
                key[3] = numZERO;
                num.d = trans_Afg_to_E;
                spop2_add(pop_E, key, num);

                size_pop_E.d += trans_Afg_to_E;
                }
                if (((envir_configure[(int)0] == 1) && (int_Af_gctime > 0.0))) {
                trans_Af_to_E = (int_fecundity * size_pop_Af.d * trans_Af_bm * (1.0 / int_Af_gctime));

                key[0] = numZERO;
                key[1] = numZERO;
                key[2] = numZERO;
                key[3] = numZERO;
                num.d = trans_Af_to_E;
                spop2_add(pop_E, key, num);

                size_pop_E.d += trans_Af_to_E;
                }
                trans_Af = (size_pop_Afj.d + size_pop_Af.d + size_pop_Afg.d);

                trans_Af_X = (completed_pop_Afj[proc_Afj_lifetime].d + completed_pop_Af[proc_Af_lifetime].d + completed_pop_Afg[proc_Afg_lifetime].d);

                if ((TIME == envir_experiment[(int)0])) {
                trans_intro_Afj = envir_experiment[(int)1];

                key[0].d = envir_experiment[(int)2];
                key[1].d = envir_experiment[(int)3];
                key[2].d = envir_experiment[(int)4];
                num.d = trans_intro_Afj;
                spop2_add(pop_Afj, key, num);

                size_pop_Afj.d += trans_intro_Afj;
                }

                if (((bsvol < model_param[par_Eh_bs_thr]) || (envir_temp[(int)(TIME-1)] < model_param[par_Eh_T_thr]))) {
                trans_Eh_to_Eh = spop2_harvest(pop_Eh, pop_Eh, fun_harvest_trans_Eh_to_Eh).d;
                }
                trans_L_to_P = spop2_harvest(popdone_pop_L[proc_L_dev], pop_P, fun_harvest_trans_L_to_P).d;
                trans_P_to_Afj = spop2_harvest(popdone_pop_P[proc_P_dev], pop_Afj, fun_harvest_trans_P_to_Afj).d;
                trans_Afj_to_Af = spop2_harvest(popdone_pop_Afj[proc_Afj_fbm], pop_Af, fun_harvest_trans_Afj_to_Af).d;
                if ((envir_configure[(int)0] == 0)) {
                trans_Af_to_Afg = spop2_harvest(popdone_pop_Af[proc_Af_bm], pop_Afg, fun_harvest_trans_Af_to_Afg).d;
                }
                if ((envir_configure[(int)0] == 0)) {
                trans_Afg_to_Af = spop2_harvest(popdone_pop_Afg[proc_Afg_gc], pop_Af, fun_harvest_trans_Afg_to_Af).d;
                }

                size_pop_Eh = spop2_size(pop_Eh);
                size_pop_P = spop2_size(pop_P);
                size_pop_Afj = spop2_size(pop_Afj);
                size_pop_Af = spop2_size(pop_Af);
                size_pop_Afg = spop2_size(pop_Afg);






                spop2_empty(&popdone_pop_Eh[0]);
                spop2_empty(&popdone_pop_Eh[1]);
                spop2_empty(&popdone_pop_Eh[2]);
                spop2_empty(&popdone_pop_Eh[3]);

                spop2_empty(&popdone_pop_L[0]);
                spop2_empty(&popdone_pop_L[1]);
                spop2_empty(&popdone_pop_L[2]);
                spop2_empty(&popdone_pop_L[3]);

                spop2_empty(&popdone_pop_P[0]);
                spop2_empty(&popdone_pop_P[1]);
                spop2_empty(&popdone_pop_P[2]);
                spop2_empty(&popdone_pop_P[3]);

                spop2_empty(&popdone_pop_Afj[0]);
                spop2_empty(&popdone_pop_Afj[1]);
                spop2_empty(&popdone_pop_Afj[2]);
                spop2_empty(&popdone_pop_Afj[3]);

                spop2_empty(&popdone_pop_Af[0]);
                spop2_empty(&popdone_pop_Af[1]);
                spop2_empty(&popdone_pop_Af[2]);
                spop2_empty(&popdone_pop_Af[3]);

                spop2_empty(&popdone_pop_Afg[0]);
                spop2_empty(&popdone_pop_Afg[1]);
                spop2_empty(&popdone_pop_Afg[2]);
                spop2_empty(&popdone_pop_Afg[3]);

        }

        ret[0] = size_pop_E.d;
        if (CHECK(ret[0])) {goto endall;};
        ret[1] = size_pop_Eh.d;
        if (CHECK(ret[1])) {goto endall;};
        ret[2] = size_pop_L.d;
        if (CHECK(ret[2])) {goto endall;};
        ret[3] = size_pop_P.d;
        if (CHECK(ret[3])) {goto endall;};
        ret[4] = size_pop_Afj.d;
        if (CHECK(ret[4])) {goto endall;};
        ret[5] = size_pop_Af.d;
        if (CHECK(ret[5])) {goto endall;};
        ret[6] = size_pop_Afg.d;
        if (CHECK(ret[6])) {goto endall;};

        ret += 7;

        iret[0] = int_bsvol_add;
        if (CHECK(iret[0])) {goto endall;};
        iret[1] = int_bsvol_remain;
        if (CHECK(iret[1])) {goto endall;};
        iret[2] = bsvol;
        if (CHECK(iret[2])) {goto endall;};
        iret[3] = int_frac_dsc;
        if (CHECK(iret[3])) {goto endall;};
        iret[4] = int_E_lifetime;
        if (CHECK(iret[4])) {goto endall;};
        iret[5] = int_E_devtime;
        if (CHECK(iret[5])) {goto endall;};
        iret[6] = int_E_lifetime_dsc;
        if (CHECK(iret[6])) {goto endall;};
        iret[7] = int_L_fdens;
        if (CHECK(iret[7])) {goto endall;};
        iret[8] = int_L_fdens_mort_frac;
        if (CHECK(iret[8])) {goto endall;};
        iret[9] = int_L_fdens_dev_frac;
        if (CHECK(iret[9])) {goto endall;};
        iret[10] = int_L_lifetime;
        if (CHECK(iret[10])) {goto endall;};
        iret[11] = int_L_devtime;
        if (CHECK(iret[11])) {goto endall;};
        iret[12] = int_P_lifetime;
        if (CHECK(iret[12])) {goto endall;};
        iret[13] = int_P_devtime;
        if (CHECK(iret[13])) {goto endall;};
        iret[14] = int_Af_lifetime;
        if (CHECK(iret[14])) {goto endall;};
        iret[15] = int_Af_gctime;
        if (CHECK(iret[15])) {goto endall;};
        iret[16] = int_fecundity;
        if (CHECK(iret[16])) {goto endall;};
        iret[17] = int_lam_hum;
        if (CHECK(iret[17])) {goto endall;};
        iret[18] = int_lam_novec;
        if (CHECK(iret[18])) {goto endall;};
        iret[19] = trans_Af_bm;
        if (CHECK(iret[19])) {goto endall;};

        iret[20] = trans_E_to_Eh;
        if (CHECK(iret[20])) {goto endall;};
        iret[21] = trans_Eh_to_L;
        if (CHECK(iret[21])) {goto endall;};
        iret[22] = trans_Afg_gc;
        if (CHECK(iret[22])) {goto endall;};
        iret[23] = trans_Afg_to_E;
        if (CHECK(iret[23])) {goto endall;};
        iret[24] = trans_Af_to_E;
        if (CHECK(iret[24])) {goto endall;};
        iret[25] = trans_Af;
        if (CHECK(iret[25])) {goto endall;};
        iret[26] = trans_Af_X;
        if (CHECK(iret[26])) {goto endall;};
        iret[27] = trans_intro_Afj;
        if (CHECK(iret[27])) {goto endall;};

        iret[28] = trans_Eh_to_Eh;
        if (CHECK(iret[0])) {goto endall;};
        iret[29] = trans_L_to_P;
        if (CHECK(iret[1])) {goto endall;};
        iret[30] = trans_P_to_Afj;
        if (CHECK(iret[2])) {goto endall;};
        iret[31] = trans_Afj_to_Af;
        if (CHECK(iret[3])) {goto endall;};
        iret[32] = trans_Af_to_Afg;
        if (CHECK(iret[4])) {goto endall;};
        iret[33] = trans_Afg_to_Af;
        if (CHECK(iret[5])) {goto endall;};

        iret += 34;

    }

  endall:

    *success = TIME;

    if (file1 && file1[0]!=' ') {
        file = fopen(file1,"wb");
        if (!file) {
            *success = 0;
        } else {
            rewind(file);

            buffsz = spop2_buffsize(pop_E);
            buff = spop2_savestate(pop_E);
            fwrite(&buffsz, sizeof(unsigned int), 1, file);
            fwrite(buff, buffsz, 1, file);
            free(buff);

            buffsz = spop2_buffsize(pop_Eh);
            buff = spop2_savestate(pop_Eh);
            fwrite(&buffsz, sizeof(unsigned int), 1, file);
            fwrite(buff, buffsz, 1, file);
            free(buff);

            buffsz = spop2_buffsize(pop_L);
            buff = spop2_savestate(pop_L);
            fwrite(&buffsz, sizeof(unsigned int), 1, file);
            fwrite(buff, buffsz, 1, file);
            free(buff);

            buffsz = spop2_buffsize(pop_P);
            buff = spop2_savestate(pop_P);
            fwrite(&buffsz, sizeof(unsigned int), 1, file);
            fwrite(buff, buffsz, 1, file);
            free(buff);

            buffsz = spop2_buffsize(pop_Afj);
            buff = spop2_savestate(pop_Afj);
            fwrite(&buffsz, sizeof(unsigned int), 1, file);
            fwrite(buff, buffsz, 1, file);
            free(buff);

            buffsz = spop2_buffsize(pop_Af);
            buff = spop2_savestate(pop_Af);
            fwrite(&buffsz, sizeof(unsigned int), 1, file);
            fwrite(buff, buffsz, 1, file);
            free(buff);

            buffsz = spop2_buffsize(pop_Afg);
            buff = spop2_savestate(pop_Afg);
            fwrite(&buffsz, sizeof(unsigned int), 1, file);
            fwrite(buff, buffsz, 1, file);
            free(buff);

            fclose(file);
        }
    }

    spop2_free(&pop_E);
    spop2_free(&pop_Eh);
    spop2_free(&(popdone_pop_Eh[0]));
    spop2_free(&(popdone_pop_Eh[1]));
    spop2_free(&(popdone_pop_Eh[2]));
    spop2_free(&(popdone_pop_Eh[3]));
    spop2_free(&pop_L);
    spop2_free(&(popdone_pop_L[0]));
    spop2_free(&(popdone_pop_L[1]));
    spop2_free(&(popdone_pop_L[2]));
    spop2_free(&(popdone_pop_L[3]));
    spop2_free(&pop_P);
    spop2_free(&(popdone_pop_P[0]));
    spop2_free(&(popdone_pop_P[1]));
    spop2_free(&(popdone_pop_P[2]));
    spop2_free(&(popdone_pop_P[3]));
    spop2_free(&pop_Afj);
    spop2_free(&(popdone_pop_Afj[0]));
    spop2_free(&(popdone_pop_Afj[1]));
    spop2_free(&(popdone_pop_Afj[2]));
    spop2_free(&(popdone_pop_Afj[3]));
    spop2_free(&pop_Af);
    spop2_free(&(popdone_pop_Af[0]));
    spop2_free(&(popdone_pop_Af[1]));
    spop2_free(&(popdone_pop_Af[2]));
    spop2_free(&(popdone_pop_Af[3]));
    spop2_free(&pop_Afg);
    spop2_free(&(popdone_pop_Afg[0]));
    spop2_free(&(popdone_pop_Afg[1]));
    spop2_free(&(popdone_pop_Afg[2]));
    spop2_free(&(popdone_pop_Afg[3]));

}

int main(int argc, char *argv[]) {
    return 0;
}

