#' Write pts_fun
#'
#' @description Internal function to write the pts_fun code driving SimInf package to implement deterministic population dynamics of Aedes Albopictus and synthetic estimates of risk.
#'
#' @usage build_pts_fun(u0, v0, gdata, ldata, diapause_interv)
#'
#' @param u0 data.frame describing the initial population stage for each compartment in each parcel. can be generated by [iniState()] function (see documentation of the function for more details on the structure).
#' @param v0 continuous variables. Contains post time step state of vector population as well as daily meteorological data.
#' @param gdata list of global data
#' @param ldata matrix of local data
#' @param vector string vector species
#' @param diapause_interv interval of days defining favorable period for mosquitoes
#' @param prev_control data.frame or data.table describing preventive control measure implemented. Required columns: 'action', 'loc', 'start', 'end', 'p' (see details)
#' @param ref_norm numeric value, rainfall normalization factor / reference value (>0)
#'
#'  @details
#'  Preventive control content:
#'  'action' column must be strings 'K', 'L' or 'A'. 'K': Source reduction (removal or destruction of breeding sites); 'L': Chemical Larviciding; 'A': Fogging or Area Spraying (targets adult mosquitoes)
#'  'loc' column must be a parcel id
#'  'start' is the first day of implementation of the measure
#'  'end' is the last day of implementation of the measure (the control is implemented every day in between)
#'  'p' must be a number between 0 and 1. It is for the "K" action: the proportion of sites daily removed during the action ; for the "A" action: the additional daily mortality of adults due to action and for the "L" action: the additional daily mortality of larvae due to larvicide
#'
#' @return String containing C code used as pts_fun by SimInf package
#'
#' @importFrom data.table month mday `:=`
#'
#'
#' @keywords internal
#'
#' @noRd

build_pts_fun <- function(u0,
                          v0,
                          gdata,
                          ldata,
                          vector,
                          virus,
                          diapause_interv,
                          TS_sim,
                          prev_control,
                          ref_norm){

  ## Check if ref_norm < 0 or not numeric turn to 100 and sent a warning
  if(!inherits(ref_norm, c("numeric", "integer"))| ref_norm < 0 | length(ref_norm) != 1){
    ref_norm <- 100
    warning("ref_norm must be a number > 0, the provided object didn't fit the expected requirements and was replaced by 100")
  }

  if(!is.null(diapause_interv)){
    diapause_string <- ""

    for(i in 0:(round(length(diapause_interv)/2)-1)){

      if(is.na(diapause_interv[i*2+2]) || (i*2+2 > length(diapause_interv))){
        diapause_string <- paste0(diapause_string, "(int)t >= ", diapause_interv[i*2+1])
      } else {
        if(i < (round(length(diapause_interv)/2)-1)){
          diapause_string <- paste0(diapause_string, paste("((int)t >= ",diapause_interv[i*2+1]," && (int)t < ",diapause_interv[i*2+2],") || "))
        } else {
          diapause_string <- paste0(diapause_string, paste("((int)t >= ",diapause_interv[i*2+1]," && (int)t < ",diapause_interv[i*2+2],")"))
        }
      }
    }

    # Gestion du dernier intervalle si la longueur de diapause_interv est impaire
    if(length(diapause_interv) %% 2 == 1){
      diapause_string <- paste0(diapause_string, " || (int)t >= ", diapause_interv[length(diapause_interv)])
    }
  }

  resetting_string <- ""
  resetting_times <- which(data.table::month(TS_sim$time_serie_date) == 1 & data.table::mday(TS_sim$time_serie_date) == 1) - 1

  for(i in resetting_times){
    if(resetting_string == "")
      resetting_string <- paste0(resetting_string, "(int)t ==",i - 1) else
        resetting_string <- paste0(resetting_string, "|| (int)t ==",i - 1)
  }

  PL_interv <- NULL
  PA_interv <- NULL
  PK_interv <- NULL

  if(!is.null(prev_control)){
    prev_control[, `:=`(
      start_time = match(start, TS_sim$time_serie_date) %>% TS_sim$time_serie_num[.],
      end_time = match(end, TS_sim$time_serie_date) %>% TS_sim$time_serie_num[.],
      id = seq(.N))]

    for(interv in prev_control[action == "L", id]){
      PL_interv %<>% paste(.,
                           paste0(c('if((int)t >= ',prev_control[id == interv,  "start_time"],' && (int)t <= ',prev_control[id == interv, "end_time"],
                                    '){if(fmL + ldata[', which(rownames(ldata) == paste0("CSS_",interv)) - 1,'] > 1){ fmL =  1; }else{fmL =  fmL + ldata[', which(rownames(ldata) == paste0("CSS_",interv)) - 1,'];}
                                  }
                                  '), collapse =""),
                           collapse =" \n")
    }

    for(interv in prev_control[action == "A", id]){
      PA_interv %<>% paste(.,
                           paste0(c('if((int)t >= ',prev_control[id == interv,  "start_time"],' && (int)t <= ',prev_control[id == interv, "end_time"],
                                    '){if(fmA + ldata[', which(rownames(ldata) == paste0("CSS_",interv)) - 1,'] > 1){fmA = 1 ;} else {fmA = fmA + ldata[', which(rownames(ldata) == paste0("CSS_",interv)) - 1,'];}
                                  //v_new[', which(rownames(v0) == "test") - 1,'] = 1L;
                                  interv_Adultm = interv_Adultm + ldata[', which(rownames(ldata) == paste0("CSS_",interv)) - 1,'];
                                  }
                                  '), collapse =""),
                           collapse =" \n")
    }



    for(interv in prev_control[action == "K", id]){
      PK_interv %<>% paste(.,
                           paste0(c('if((int)t >= ',prev_control[id == interv,  "start_time"],' && (int)t <= ',prev_control[id == interv, "end_time"],
                                    '){
                                    kP = kP * (1 - ldata[', which(rownames(ldata) == paste0("CSS_",interv)) - 1,']);
                                    kL = kL * (1 - ldata[', which(rownames(ldata) == paste0("CSS_",interv)) - 1,']);
                                  //v_new[', which(rownames(v0) == "test") - 1,'] = 1L;
                                  }
                                  '), collapse =""),
                           collapse =" \n")
    }
  }

  ###########################################################
  ### Deterministic transitions for mosquitoes life cycle ###
  ###########################################################
  options(scipen=999)

  pts_fun <- paste0('

  //// Declare variables

const int nNodes = (int)',nrow(u0), 'L;
const int nCpmt_u = (int)',ncol(u0), 'L;
const int nCpmt_v = (int)',nrow(v0), 'L;
const int * u_0 = &u[-node * nCpmt_u];
const double * v_0 = &v[-node * nCpmt_v];

  //// Population Dynamics

  // update diapause
  ', if(!is.null(diapause_interv)) paste0('v_new[', which(rownames(v0) == "z") - 1,'] = 0;
  if(',diapause_string,')
  v_new[', which(rownames(v0) == "z") - 1,'] = 1;'),
                    '
  // update temperature and carrying capacities
  double temperature;
  long kP;
  long kL;
  double fk;

  temperature = ldata[', which(rownames(ldata) == "Tp_1") - 1,' + (int)t];
  v_new[', which(rownames(v0) == "temperature") - 1,'] = temperature;


  // Update rain
  v_new[', which(rownames(v0) == "RR_day") - 1,'] = ldata[', which(rownames(ldata) == "RR_1") - 1,' + (int)t];
  double RR_day;
  RR_day = v_new[', which(rownames(v0) == "RR_day") - 1,'];


  double RR_7days;
  RR_7days = 0;
  int rainyD;
  for(rainyD = 0; rainyD <= 6; ++rainyD){
  if(((int)t - rainyD) >= 0)
  RR_7days =  RR_7days + ldata[', which(rownames(ldata) == "RR_1") - 1,' + (int)t - rainyD];
  }

  v_new[', which(rownames(v0) == "RR_7days") - 1,'] = RR_7days;

  // fkl = klmin + min(klvar * (raincumul7/100), klvar) : arbocarto-DGS

  fk = ldata[', which(rownames(ldata) == "kvar") - 1,'] * (RR_7days / ',ref_norm,');

  // 150 replace : ldata[(rownames(ldata) %>% startsWith(., "RR") %>% which %>% min) : (rownames(ldata) %>% startsWith(., "RR") %>% which %>% max),] %>% max

  if(fk < ldata[', which(rownames(ldata) == "kvar") - 1,']){
  kP = ldata[', which(rownames(ldata) == "kfix") - 1,'] + fk;
  kL = ldata[', which(rownames(ldata) == "kfix") - 1,'] + fk;
  }else{
  kP = ldata[', which(rownames(ldata) == "kfix") - 1,'] + ldata[', which(rownames(ldata) == "kvar") - 1,'];
  kL = ldata[', which(rownames(ldata) == "kfix") - 1,'] + ldata[', which(rownames(ldata) == "kvar") - 1,'];
  }

  //v_new[', which(rownames(v0) == "test") - 1,'] = 0;

  // if Preventive reduction of environmental carrying capacities (PK) multiply kP and kL by prev_control$p and ldata CSS
',if(!is.null(PK_interv)) PK_interv,'


  if(kP < 1) kP = 1;
  if(kL < 1) kL = 1;

  v_new[', which(rownames(v0) == "kP") - 1,'] = kP;
  v_new[', which(rownames(v0) == "kL") - 1,'] = kL;

 v_new[', which(rownames(v0) == "E2I") - 1,'] = ',
                    if(virus == "DEN")
                      '0.11 * pow(temperature,2) - 7.13 * temperature + 121.17;' else ## equation from arbocarto
                      # '4 + exp(5.15-0.123*temperature);' else ## equation from AedesRisk
                    # faedesrisk <- rlang::as_function(~ 4 + exp(5.15-0.123*.x))
                    # farbocarto <- rlang::as_function(~ 0.11 * .x^2 - 7.13 * .x + 121.17)
                    # ggplot(data.frame(x = -3:37), aes(x)) +
                    #   geom_function(fun = faedesrisk, colour = "red")+
                    #   geom_function(fun = farbocarto, colour = "blue")
                        if(virus == "CHI")
                          '4 + exp(5.15-0.123*temperature);' else
                            if(virus == "ZIK") # https://journals.plos.org/plosntds/article?id=10.1371/journal.pntd.0008047
                              '1/(7-(-0.667 + 0.378*(temperature-26))/(0.299+0.027*(temperature-26)));'
                    ,'

  // Development and mortality functions

  // EGGS
  // eggs layed by infected mosquitoes
  int neweggI;
  neweggI = u[', which(names(u0) == "Neggs") - 1,'] - v[', which(rownames(v0) == "prevEggs") - 1,'];
  v_new[', which(rownames(v0) == "prevEggs") - 1,'] = u[', which(names(u0) == "Neggs") - 1,'];
  // eggs layed by susceptible mosquitoes
  int neweggS;
  neweggS =', gdata["gammaAo"], ' * (v[', which(rownames(v0) == "A1om") - 1,'] * ', gdata["beta1"], ' +  v[', which(rownames(v0) == "A2om") - 1,'] * ', gdata["beta2"], ');

  v_new[', which(rownames(v0) == "newEggs") - 1,'] = neweggS + neweggI;

  //  eggs development into larvae and mortality
  double fdevE;
  if(',feggs(vector, gdata),' > 0){
  fdevE = v_new[', which(rownames(v0) == "z") - 1,'] * ',feggs(vector, gdata),';
  }else{
  fdevE = 0;
  }

  double fmuE;
  fmuE = ', gdata["muE"],';
  if(RR_day > 80){
  fmuE = fmuE + ', gdata["muErain"],';
  }

  long varEm;
  if((', gdata["muE"],' + fdevE) > 1){
  varEm = neweggI + neweggS - v[', which(rownames(v0) == "Em") - 1,'];
  } else{
  varEm = neweggI + neweggS - v[', which(rownames(v0) == "Em") - 1,'] * (fmuE + fdevE);
  }

  // LARVAE

  //  larvae development into pupae
  double fdevL;
  if(',flarvae(vector, gdata),' < 0){
  fdevL = 0;
  } else {
  fdevL = ',flarvae(vector, gdata),';
  }

  //  larvae mortality
  double fmL;
  // if(kL > 0){ elways true based on above : if(kP < 1) kP = 1;
  fmL = (', gdata["mu1L"], ' * exp((temperature-10)*', gdata["mu2L"], ') + ', gdata["mu3L"], ') * (1 + v[', which(rownames(v0) == "Lm") - 1,']/kL);
  // } else {
  // fmL = 1;
  // }

  if(RR_day > 80){
  fmL = fmL + ', gdata["muLrain"],';
  }


  // if Preventive Larvicide (PL) in prev_control and time between ... (select the right rows) multiply fmL by prev_control$p and ldata CSS
',if(!is.null(PL_interv)) PL_interv,'


  if(fmL > 1) fmL = 1;

  long varLm;
  if((fdevL + fmL) > 1){
  varLm = v[', which(rownames(v0) == "Em") - 1,'] * fdevE - v[', which(rownames(v0) == "Lm") - 1,'] ;
  } else {
  varLm = v[', which(rownames(v0) == "Em") - 1,'] * fdevE - v[', which(rownames(v0) == "Lm") - 1,'] * (fdevL + fmL) ;
  }

  // PUPAE

  //  pupae development into emerging adult
  double fdevP;
  fdevP = ', fpupae(vector, gdata),';
  if(fdevP < 0)
  fdevP = 0;

  //  pupae mortality
  double fmP;
  fmP = (', gdata["mu1P"], ' * exp((temperature-10)*', gdata["mu2P"], ') + ', gdata["mu3P"], ');

  if(RR_day > 80){
  fmP = fmP + ', gdata["muLrain"],';
  }

  long varPm;
  if((fdevP + fmP) > 1){
  varPm = v[', which(rownames(v0) == "Lm") - 1,'] * fdevL - v[', which(rownames(v0) == "Pm") - 1,'] ;
  } else {
  varPm = v[', which(rownames(v0) == "Lm") - 1,'] * fdevL - v[', which(rownames(v0) == "Pm") - 1,'] * (fdevP + fmP) ;
  }

  // ADULTS

  //  aldult mortality
  double fmA;
  fmA = ', gdata["mu1A"], ' * exp((temperature - 10)*', gdata["mu2A"], ') + ', gdata["mu3A"], ';
  if(fmA < ', gdata["mu3A"], ')
  fmA = ', gdata["mu3A"], ';

  //  emerging aldult survival
  double fsAEm;
  //  if(kP > 0){ ## alway true based on previous if(kP < 1) kP = 1;
  fsAEm = exp(-', gdata["muEM"], ' * (1 + v[', which(rownames(v0) == "Pm") - 1,']/kP));
  //  } else {
  //  fsAEm = 0;
  //  }

  // if Preventive Adulticide (PA) in prev_control and time between ... (select the right rows) multiply fmL by prev_control$p and ldata CSS

  double interv_Adultm;
  interv_Adultm = 0;

',if(!is.null(PA_interv)) PA_interv,'

  v_new[', which(rownames(v0) == "interv_Am") - 1,'] = interv_Adultm;

  if(fmA > 1) fmA = 1;

  //  aldult mortality in research activity
  double fmAr;
  fmAr = fmA + ', gdata["muR"], ';

  //  aldult gorging activity
  double fAg;
    if(',fadult(vector, gdata),' > 0){
  fAg = ',fadult(vector, gdata),';
  } else {
  fAg = 0;
  }

  v_new[', which(rownames(v0) == "G2O") - 1,'] = fAg;

  double varAemm;
  varAemm =  v[', which(rownames(v0) == "Pm") - 1,'] * fdevP * ', gdata["sigma"],' * fsAEm - v[', which(rownames(v0) == "Aemm") - 1,'] * (fmA + ', gdata["gammaAem"], ') ;

  double varA1hm;
  double infA1h;
  // number of h1 gorged in stochastic
  infA1h = u[', which(names(u0) == "ninfm1") - 1,'] - v[', which(rownames(v0) == "nIm1") - 1,'];
  v_new[', which(rownames(v0) == "nIm1") - 1,'] = u[', which(names(u0) == "ninfm1") - 1,'];
  varA1hm = v[', which(rownames(v0) == "Aemm") - 1,'] * ', gdata["gammaAem"], ' - (v[', which(rownames(v0) == "A1hm") - 1,'] - infA1h) * (fmAr + ', gdata["gammaAh"], ') - infA1h ;

  double varA1gm;
  varA1gm = v[', which(rownames(v0) == "A1hm") - 1,'] * ', gdata["gammaAh"], ' - v[', which(rownames(v0) == "A1gm") - 1,'] * (fmA + fAg) ;

  double varA1om;
  varA1om = v[', which(rownames(v0) == "A1gm") - 1,'] * fAg - v[', which(rownames(v0) == "A1om") - 1,'] * (fmAr + ', gdata["gammaAo"], ') ;

  double varA2hm;
  double infA2h;
  // number of h1 gorged in stochastic
  infA2h = u[', which(names(u0) == "ninfm2") - 1,'] - v[', which(rownames(v0) == "nIm2") - 1,'];
  v_new[', which(rownames(v0) == "nIm2") - 1,'] = u[', which(names(u0) == "ninfm2") - 1,'];
  varA2hm = (v[', which(rownames(v0) == "A1om") - 1,'] + v[', which(rownames(v0) == "A2om") - 1,']) * ', gdata["gammaAo"], ' - (v[', which(rownames(v0) == "A2hm") - 1,'] - infA2h) * (fmAr + ', gdata["gammaAh"], ') - infA2h ;

  double varA2gm;
  varA2gm = v[',which(rownames(v0) == "A2hm") - 1,'] * ', gdata["gammaAh"], ' - v[', which(rownames(v0) == "A2gm") - 1,'] * (fmA + fAg) ;

  double varA2om;
  varA2om = v[', which(rownames(v0) == "A2gm") - 1,'] * fAg - v[', which(rownames(v0) == "A2om") - 1,'] * (fmAr + ', gdata["gammaAo"], ');

  //  update mosquito population vector
   //  eggs
   v_new[', which(rownames(v0) == "Em") - 1,'] = v[', which(rownames(v0) == "Em") - 1,'] + round(varEm) ;
   //  larvae
   v_new[', which(rownames(v0) == "Lm") - 1,'] = v[', which(rownames(v0) == "Lm") - 1,'] + round(varLm) ;
   //  pupae
   v_new[', which(rownames(v0) == "Pm") - 1,'] = v[', which(rownames(v0) == "Pm") - 1,'] + round(varPm) ;
   //  emerging adult
   v_new[', which(rownames(v0) == "Aemm") - 1,'] = v[', which(rownames(v0) == "Aemm") - 1,'] + round(varAemm) ;
   //  nulliparous host-seeking adult
   v_new[', which(rownames(v0) == "A1hm") - 1,'] = v[', which(rownames(v0) == "A1hm") - 1,'] + round(varA1hm) ;
   //  nulliparous gorged adult
   v_new[', which(rownames(v0) == "A1gm") - 1,'] = v[', which(rownames(v0) == "A1gm") - 1,'] + round(varA1gm) ;
   //  nulliparous oviposition-site-seeking adult
   v_new[', which(rownames(v0) == "A1om") - 1,'] = v[', which(rownames(v0) == "A1om") - 1,'] + round(varA1om) ;
   //  parous host-seeking adult
   v_new[', which(rownames(v0) == "A2hm") - 1,'] = v[', which(rownames(v0) == "A2hm") - 1,'] + round(varA2hm) ;
   //  parous gorged adult
   v_new[', which(rownames(v0) == "A2gm") - 1,'] = v[', which(rownames(v0) == "A2gm") - 1,'] + round(varA2gm) ;
   //  parous oviposition-site-seeking adult
   v_new[', which(rownames(v0) == "A2om") - 1,'] = v[', which(rownames(v0) == "A2om") - 1,'] + round(varA2om) ;

  // reset mosquitoes pop (except eggs) during winter
',if(!is.null(diapause_interv)) paste('
  if(',resetting_string,'){
   //  larvae
   v_new[', which(rownames(v0) == "Lm") - 1,'] = 0 ;
   //  pupae
   v_new[', which(rownames(v0) == "Pm") - 1,'] = 0 ;
   //  emerging adult
   v_new[', which(rownames(v0) == "Aemm") - 1,'] = 0 ;
   //  nulliparous host-seeking adult
   v_new[', which(rownames(v0) == "A1hm") - 1,'] = 0 ;
   //  nulliparous gorged adult
   v_new[', which(rownames(v0) == "A1gm") - 1,'] = 0 ;
   //  nulliparous oviposition-site-seeking adult
   v_new[', which(rownames(v0) == "A1om") - 1,'] = 0 ;
   //  parous host-seeking adult
   v_new[', which(rownames(v0) == "A2hm") - 1,'] = 0 ;
   //  parous gorged adult
   v_new[', which(rownames(v0) == "A2gm") - 1,'] = 0 ;
   //  parous oviposition-site-seeking adult
   v_new[', which(rownames(v0) == "A2om") - 1,'] = 0 ;
  }'),'


//// Calcul of R0

double R0;

// vectorial capacity
double VectCap;

// Vector competence
double VectComp;

// FIX ME adapt to ZIK CHI viruses
if(((-0.0043)*pow(temperature,2)+(0.2593*temperature)-3.2705) > 0){
  VectComp = ((-0.0043)*pow(temperature,2)+(0.2593*temperature)-3.2705);
} else {
  VectComp = 0;
}

// vector density per host
double VectDens;

// Local number of adult mosquitoes
int Am_tot_loc;
Am_tot_loc = u[',which(colnames(u0) == "A1gmE") - 1,
'] + u[',which(colnames(u0) == "A1omE") - 1,
'] + u[',which(colnames(u0) == "A2hmE") - 1,
'] + u[',which(colnames(u0) == "A2gmE") - 1,
'] + u[',which(colnames(u0) == "A2omE") - 1,
'] + u[',which(colnames(u0) == "A1gmI") - 1,
'] + u[',which(colnames(u0) == "A1omI") - 1,
'] + u[',which(colnames(u0) == "A2hmI") - 1,
'] + u[',which(colnames(u0) == "A2gmI") - 1,
'] + u[',which(colnames(u0) == "A2omI") - 1,
']+ v[', which(rownames(v0) == "Aemm") - 1,
']+ v[', which(rownames(v0) == "A1hm") - 1,
']+ v[', which(rownames(v0) == "A1gm") - 1,
']+ v[', which(rownames(v0) == "A1om") - 1,
']+ v[', which(rownames(v0) == "A2hm") - 1,
']+ v[', which(rownames(v0) == "A2gm") - 1,
']+ v[', which(rownames(v0) == "A2om") - 1,'];

// Local number of host
int H;
// FIX ME different from arbocarto
// H = u[',which(colnames(u0) == "Sh") - 1,'] + u[',which(colnames(u0) == "Eh") - 1,'] + u[',which(colnames(u0) == "Ih") - 1,'] + u[',which(colnames(u0) == "Rh") - 1,'];
H = ldata[', which(rownames(ldata) == "mi_mixedpop") - 1,'];

if(H > 0 && Am_tot_loc > 0){
 if(H > 0){
  VectDens = Am_tot_loc/H;
  } else {
  VectDens = 0;
  }


  // daily bitting rate
  double bittingR;

  bittingR = (u[',which(colnames(u0) == "A2hmE") - 1,
'] + u[',which(colnames(u0) == "A2hmI") - 1,
'] + v[', which(rownames(v0) == "A1hm") - 1,
'] + v[', which(rownames(v0) == "A2hm") - 1,'])/Am_tot_loc *', gdata["gammaAh"], ' ;

  // daily survival rate
  double survival_rate;
  survival_rate = 1 - fmA * ((u[',which(colnames(u0) == "A1gmE") - 1,
'] + u[',which(colnames(u0) == "A2gmE") - 1,
'] + u[',which(colnames(u0) == "A1gmI") - 1,
'] + u[',which(colnames(u0) == "A2gmI") - 1,
']+ v[', which(rownames(v0) == "Aemm") - 1,
']+ v[', which(rownames(v0) == "A1gm") - 1,
']+ v[', which(rownames(v0) == "A2gm") - 1,']) / Am_tot_loc) - ((u[',
which(colnames(u0) == "A1omE") - 1,
'] + u[',which(colnames(u0) == "A2hmE") - 1,
'] + u[',which(colnames(u0) == "A2omE") - 1,
'] + u[',which(colnames(u0) == "A1omI") - 1,
'] + u[',which(colnames(u0) == "A2hmI") - 1,
'] + u[',which(colnames(u0) == "A2omI") - 1,
'] + v[', which(rownames(v0) == "A1hm") - 1,
'] + v[', which(rownames(v0) == "A1om") - 1,
'] + v[', which(rownames(v0) == "A2hm") - 1,
'] + v[', which(rownames(v0) == "A2om") - 1,'])/Am_tot_loc) * fmAr;

  // extrinsic incubation period
  double EIP;
  //EIP = 0.11 * pow(temperature,2) - 7.13 * temperature + 121.17;
  EIP = v_new[', which(rownames(v0) == "E2I") - 1,'];

  VectCap = (VectDens * pow(bittingR, 2) * pow(survival_rate, EIP))/-log(survival_rate);

  R0 = VectCap / ', gdata["rhoH"],' * VectComp;

  if(R0 > u[',which(colnames(u0) == "Sh") - 1,']){
    v_new[', which(rownames(v0) == "R0") - 1,'] = u[',which(colnames(u0) == "Sh") - 1,'];
  } else {
    v_new[', which(rownames(v0) == "R0") - 1,'] = R0;
  }

} else { // if no human or no mosquitoes
  v_new[', which(rownames(v0) == "R0") - 1,'] = 0;
}

//// Include mobility for infections

//// betaMext: infection of host by mosquitoes from another patch (probability to be infected externaly)

// proportion of infected mosquitoes weighted by the probability of being in contact (probability to be in the patch)
// initialize proportion
double wImp;
wImp = 0;

// proportion of infected mosquitoes looking for host in patch j
double hmIp;


// biting rate in patch j
double biter;

// biting rate in patch j
double Ahtot;

// in each node
int j;
for(j = 0; j <= (nNodes - 1); ++j){

  Ahtot = v_0[',which(rownames(v0) == "A1hm") - 1,' + j * ',nrow(v0),
  '] + v_0[',which(rownames(v0) == "A2hm") - 1,' + j * ',nrow(v0),
  '] +  u_0[',which(colnames(u0) == "A2hmE") - 1,' + j * ',ncol(u0),
  '] + u_0[',which(colnames(u0) == "A2hmI") - 1,' + j * ',ncol(u0),'];

  if(Ahtot > 0 && ldata[', which(rownames(ldata) == "mi_mixedpop") - 1,' + j] > 0){

  //number of bite per host
  biter = (double) (', gdata["gammaAh"],' * Ahtot) / ldata[', which(rownames(ldata) == "mi_mixedpop") - 1,' + j];
  //biter = atan(biter) * ', gdata["maxbite"],'/(M_PI/2):

  // weight pIMh by the probability to be in j for individual from
  hmIp = (double)  atan(biter) * ', gdata["maxbite"],'/(M_PI/2) * (u_0[',which(colnames(u0) == "A2hmI") - 1,' + j * ',ncol(u0), '] / Ahtot) * ldata[',rownames(ldata) %>% startsWith(., "Oij_") %>% which %>% min %>% subtract(1),' + j];

  //hmIp = (double) biter * (u_0[',which(colnames(u0) == "A2hmI") - 1,' + j * ',ncol(u0), '] / Ahtot) * ldata[',rownames(ldata) %>% startsWith(., "Oij_") %>% which %>% min %>% subtract(1),' + j];
  //hmIp = (double) (atan(gammaAh * u_0[',which(colnames(u0) == "A2hmI") - 1,' + j * ',ncol(u0), '] * (1 / ldata[', which(rownames(ldata) == "mi_mixedpop") - 1,' + j])) * maxbite) / (M_PI/2) * ldata[',rownames(ldata) %>% startsWith(., "Oij_") %>% which %>% min %>% subtract(1),' + j];
  //hmIp = (double)  u_0[',which(colnames(u0) == "A2hmI") - 1,' + j * ',ncol(u0), '] * ldata[',rownames(ldata) %>% startsWith(., "Oij_") %>% which %>% min %>% subtract(1),' + j] * (1 / ldata[', which(rownames(ldata) == "mi_mixedpop") - 1,' + j]);

  // add this probability to beta
  wImp = wImp + hmIp;

  }
}

v_new[', which(rownames(v0) == "betaMext") - 1,'] = (double) wImp;



//// betaHext: infection of mosquitoes by humans from another patch (probability to be infected externaly)

// proportion of infected humans weighted by the probability of being in contact (probability to be in the patch)
double wIhp;
// initialize proportion
wIhp =  0.00;

// total number of host
int htot;

// proportion of infected mosquitoes looking for host in the patch
double Ip;

int k;
// in each node
for(k = 0; k <= (nNodes - 1); ++k){

  // total number of host in patch k
  htot = u_0[',which(colnames(u0) == "Sh") - 1,' + k * ',ncol(u0),
'] + u_0[',which(colnames(u0) == "Eh") - 1,' + k * ',ncol(u0),
'] + u_0[',which(colnames(u0) == "Ih") - 1,' + k * ',ncol(u0),
'] + u_0[',which(colnames(u0) == "Rh") - 1,' + k * ',ncol(u0),'];

  // proportion of infected host in patch k
  if(htot > 0){
    Ip = (double) u_0[',which(colnames(u0) == "Ih") - 1,' + k * ',ncol(u0),'] / htot;
  } else {
    Ip = (double) 0;
  }

  // weight pIMh by the probability to be in j for individual from
  Ip = Ip * ldata[',rownames(ldata) %>% startsWith(., "Dij_") %>% which %>% min %>% subtract(1),' + k];

  // add this probability to beta
  wIhp = wIhp + Ip;
}

v_new[', which(rownames(v0) == "betaHext") - 1,'] = (double) wIhp;


  return 1;
')
  options(scipen=0)

  return(pts_fun)
}
